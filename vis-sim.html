<!DOCTYPE html>
<html>
    <head>
        <title>Peer-To-Peer Sync9</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <script src="https://dglittle.github.io/cdn/random001.js"></script>
        <script src="https://dglittle.github.io/cdn/utils004.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <script src="https://unpkg.com/d3-dag@0.2.6"></script>
        <script src="./sync9.js"></script>
        <script src="./sync9_peer.js"></script>
        <script src="./trial.js"></script>
        <script>
        var P = null;
        const N = 6;
        function begin() {
            // Compute the size of SVG elements
            const body = document.getElementsByTagName('body')[0];
            var computedStyle = getComputedStyle(body);

            const bh = body.clientHeight
                - parseFloat(computedStyle.paddingTop)
                - parseFloat(computedStyle.paddingBottom);
            const bw = body.clientWidth
                - parseFloat(computedStyle.paddingLeft)
                - parseFloat(computedStyle.paddingRight);
            
            const ratio = document.documentElement.clientWidth
                          / document.documentElement.clientHeight;
            const elw = Math.min((ratio > 1) ? bw/2 : bw, 500),
                  elh = Math.min((ratio > 1) ? bh : bh/2, 500);

            d3.select("svg.dag").attr("viewBox", `-30 -30 ${elw+60} ${elh+60}`);
            const svg = d3.select("svg.network")
                          .attr("viewBox", `-10 -10 ${elw+10} ${elh+10}`);
            const sim_scale = Math.min(1, Math.min(elw, elh)/500);
            
            var nodes = [];
            var links = [];
            var p_data = null;

            document.getElementById('edit_prob').oninput = () => {
                const exp = -2 * Math.log(N)/Math.log(0.25);
                EDIT_PROB = Math.pow(document.getElementById('edit_prob').value, exp);
            };
            document.getElementById('edit_prob').oninput();

            document.getElementById('connect_prob').oninput = () => {
                CONNECT_PROB = document.getElementById('connect_prob').value;
            };
            document.getElementById('connect_prob').oninput();

            document.getElementById('timing').oninput = () => {
                TIMING = 1000*Math.pow(10, -document.getElementById('timing').value);
            };
            document.getElementById('timing').oninput();

            var trial = new Trial({
                peers: N});
            trial.on("topology", update_links);
            trial.on("edit", rec_edit);
            trial.begin();

            /* Recompute nodes and links when they get changed (ie, on the topology event) */
            function update_links(peers) {
                net_peers = peers;
                // Note the current number of links and nodes to see if they change.
                // The event should fire after a single change so we should never miss a change due to counting
                let nodes_old_len = nodes.length;
                let links_old_len = links.length;
                // Copy over the old nodes' locations so that we can update seamlessly
                let nodes_new = Object.keys(peers).map(uid => {
                    let node = {id: uid}
                    for (let peer of nodes) {
                        if (peer.id === uid) {
                            node.x = peer.x;
                            node.y = peer.y;
                            break;
                        }
                    }
                    if (!p_data) {
                        P = peers[uid];
                        node.selected = true;
                        p_data = node;
                    }
                    return node;
                })
                // Done computing nodes

                links = [];
                // Let's traverse the graph
                // Keep track of what we've seen
                let seen_peers = new Set();
                // Recursively explore the graph
                function add_links(peer) {
                    if (seen_peers.has(peer))
                        return;
                    seen_peers.add(peer);
                    for (let link of Object.keys(peers[peer].peers)) {
                        links.push({source: peer, target: link})
                        add_links(link)
                    }
                }
                // Pick the "first" peer and start traversing
                add_links(Object.keys(peers)[0]);
                // Done computing links

                // If the nodes or links changed, update them in the simulation
                // This might be unnecessary and it depends on the internals of the simulation
                if (nodes_new.length != nodes_old_len) {
                    nodes = nodes_new;
                    simulation.nodes(nodes);
                }
                if (links.length != links_old_len) {
                    simulation.force("link").links(links);
                }
                // Update graphics handles creating and deleting SVG elements
                if (nodes.length != nodes_old_len || links.length != links_old_len) {
                    update_graphics();
                    simulation.alpha(0.2).restart();
                }
            }
            /* When we get an edit, mark "edit time" on the peer that made it */
            function rec_edit(uid, edit) {
                let c = d3
                  .selectAll("svg.network .nodes > g")
                    .filter(d => d.id == uid)
                  .select("circle");
                if (c.classed("edit-blip-1")) {
                    c.classed("edit-blip-1", false);
                    c.classed("edit-blip-2", true);
                } else {
                    c.classed("edit-blip-2", false);
                    c.classed("edit-blip-1", true);
                }
            }
            /* Update the SVG elements with new or removed nodes and links */
            function update_graphics() {
                // Bind the nodes to the data
                node = node.data(nodes, d => d.id);
                // Remove deleted nodes
                node.exit().remove();
                // Add new nodes and draw circles on them
                let enter = node.enter()
                  .append("g")
                  .attr("data-pid", d => d.id);
                enter.append("circle")
                    .attr("r", 10)
                    .classed("node", true)
                enter.call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended))
                    .on('mouseover', hoverOn);
                node = node.merge(enter)
                    .classed("selected", d => d.selected);

                // Bind links, remove deleted, and add new.
                link = link.data(links, d => d.source.id + "-" + d.target.id);
                link.exit().remove();
                link = link.enter()
                            .append(() => {
                                   let group = document.createElementNS("http://www.w3.org/2000/svg","g");
                                   let back = document.createElementNS("http://www.w3.org/2000/svg","line");
                                   let front = document.createElementNS("http://www.w3.org/2000/svg","line");
                                   group.append(back, front);
                                   return group;
                               })
                                .merge(link);
            }
            /* Update fissure notifications for peers */
            var colors = {};
            function fis(f) {
                let m = f.a < f.b ? f.a : f.b,
                    p = f.a < f.b ? f.b : f.a;
                return {
                    min: m,
                    plus: p,
                    sign: f.a < f.b ? "+" : "-",
                    tag: `${m}:${p}`
                };
            };
            function update_fissures() {
                let fissures = new Set();
                for (let p of Object.values(trial.peers)) {
                    Object.values(p.fissures)
                        .forEach(f => fissures.add(fis(f).tag));
                }
                // Delete unused colors
                for (let f of Object.keys(colors)) {
                    if (!fissures.has(f))
                        delete colors[f];
                }
                for (let f of fissures) {
                    if (!colors[f]) {
                        // Let's find a new color
                        // What we want to do is find the color that is furthest away from every other color
                        let positions = Object.values(colors).map(c => c.angle).sort().concat([1]);
                        let best = 0,
                            biggest = positions[0];
                        for (let i = 0; i < positions.length - 1; i++) {
                            let smaller = positions[i];
                            let bigger = positions[i+1];
                            if (bigger - smaller > biggest) {
                                best = (bigger + smaller) / 2;
                                biggest = bigger - smaller;
                            }
                        }

                        colors[f] = {angle: best, color: d3.interpolateRainbow(best)};
                    }
                }
                
                let fdots = node
                  .selectAll("g.fissure")
                    .data(d => Object.values(trial.peers[d.id].fissures).map(fis),
                          f => f.tag+f.sign);
                
                fdots.exit().remove();

                let e = fdots
                  .enter()
                  .append("g")
                   .classed("fissure", true)
                
                e.append("circle")
                    .classed("fissure-circ", true)
                    .attr("r", 7)
                    .attr("fill", f => colors[f.tag].color);
                e.append('text')
                    .classed("fissure-sign", true)
                    .html(f => f.sign == "-" ? "&minus;" : "+")
                    .attr("y", 5);
                fdots = fdots.merge(e)
                    .attr("transform", (f, i) => `translate(${i * 18 + 20}, -10)`);
            }

            var s_fissure = null;
            var draw_n = 0;
            /* Draw the dag for a peer d */
            function draw_dag(d, clear) {
                // Get the timedag of the peer
                let pe = trial.peers[d.id];
                let timedag = Object.entries(pe.s9.T)
                    .map(([k, v]) => {
                        return {id: k, parentIds: Object.keys(v)};
                    });
                
                if (timedag.length > 500) {
                    d3.select("svg.dag").classed("disabled", true);
                    return false;
                }
                if (++draw_n * 50 < timedag.length) {
                    return false;
                }
                draw_n = 0;

                let x = pe.v_state();
                let z = pe.f_state();

                let dag = d3.dagStratify()(timedag);
                let layout = d3.sugiyama()
                    .size([elw, elh])
                    .layering(d3.layeringLongestPath())
                    .decross(d3.decrossTwoLayer())
                    .coord(d3.coordCenter());
                layout(dag);

                let svg = d3.select("svg.dag")
                    .classed("disabled", false);
                if (clear)
                    svg.selectAll("g").selectAll("*").remove();
                
                const size_scale = 1/(1 + timedag.length/250);
                // How to draw edges
                let line = d3.line()
                    .curve(d3.curveCatmullRom
                        .alpha(0.8))
                    .x(d => d.x)
                    .y(d => d.y);

                let fissures = Object.values(pe.fissures).map(fis);
                function color_nodes() {
                    svg
                      .selectAll('circle.dag-version')
                        .attr('stroke', ({id}) => z(id)[s_fissure] ? colors[s_fissure].color : "#4e6069");
                }
                
                // Plot edges
                let edges = svg.select("g.edges")
                    .attr('stroke-width', 3 * size_scale)
                  .selectAll('path')
                    .data(dag.links(), l => `${l.source.id}-${l.target.id}`);

                edges.enter()
                  .append('path')
                    .classed('dag-line', true)
                  .merge(edges)
                    .attr('d', ({ data }) => line(data.points));

                edges.exit().remove();
                
                let nodes = svg.select("g.nodes")
                    .attr('stroke-width', 3 * size_scale)
                  .selectAll('circle')
                    .data(dag.descendants(), n => n.id);
                
                nodes.enter()
                  .append('circle')
                    .classed('dag-version', true)
                    .attr('stroke', "#4e6069")
                    .attr("data-vid", ({id}) => id)
                  .merge(nodes)
                    .attr('r', 10 * size_scale)
                    .attr('cx', ({x, y}) => x)
                    .attr('cy', ({x, y}) => y)
                    .classed("frozen", ({id}) => x(id).frozen)
                    .classed("acked", ({id}) => x(id).acked)
                    .classed("fissured", ({id}) => Object.keys(z(id)).length);

                nodes.exit().remove();
                color_nodes();

                const arrowhead = d3.symbol().type(d3.symbolTriangle).size(60 * size_scale);
                let arrows = svg.select('g.arrows')
                  .selectAll('path')
                    .data(dag.links(), l => `${l.source.id}-${l.target.id}`);
                
                arrows.enter()
                  .append('path')
                    .classed('dag-arrow', true)
                    .attr('d', arrowhead)
                  .merge(arrows)
                    .attr('transform', ({data}) => {
                        // Last two points from the data
                        let [end, start] = data.points.reverse();
                        let dx = start.x - end.x;
                        let dy = start.y - end.y;
                        let scale = size_scale * 12 / Math.sqrt(dx * dx + dy * dy);
                        // This is the angle of the last line segment
                        let angle = Math.atan2(-dy, -dx) * 180 / Math.PI + 90;
                        return `translate(${end.x + dx * scale}, ${end.y + dy * scale}) rotate(${angle})`;
                    });
                
                arrows.exit().remove();
                
                let fissure_bars = svg.select('g.fissures')
                  .selectAll('rect')
                    .data(fissures, f => f.tag);
                
                fissure_bars.enter()
                  .append('rect')
                    .classed('dag-select', true)
                    .attr('x', elw+30)
                    .attr('fill', f => colors[f.tag].color)
                    .on('mouseover click', function (d) {
                        s_fissure = d.tag;
                        d3.selectAll('.dag-select')
                            .classed("selected", false);
                        d3.select(d3.event.target)
                            .classed("selected", true);
                        setTimeout(() => color_nodes());
                    })
                    .on('mouseout', d => {
                        if (s_fissure === d.tag)
                            s_fissure = null;
                        d3.select(d3.event.target)
                            .classed("selected", false);
                        setTimeout(() => color_nodes());
                    })
                  .merge(fissure_bars)
                    .attr('width', 500)
                    .attr('height', elh/fissures.length)
                    .attr("y", (f, i) => elh/fissures.length * i);

                fissure_bars.exit().remove(); 
                    
            }

            function draw_dag_line(d) {
                
            }
            const simulation = d3.forceSimulation()
                .force("link", d3.forceLink(links)
                                 .id(d => d.id)
                                 .distance(200 * sim_scale))
                .force("repel", d3.forceManyBody()
                                   .strength(-1500 * sim_scale)
                                   .distanceMax(400 * sim_scale))
                .force("center", d3.forceCenter(elw/2, elh/2));
            
            var link = svg.append("g")
                          .classed("links", true)
                        .selectAll("line"),

                node = svg.append("g")
                          .classed("nodes", true)
                        .selectAll("g");

            update_links(trial.peers);
            update_fissures();
            draw_dag(p_data);

            simulation.on("tick", () => {
                // Move the nodes and lines
                nodes.forEach(d => {
                    d.x = Math.min(Math.max(15, d.x), elw-15);
                    d.y = Math.min(Math.max(15, d.y), elh-15);
                })
                link
                  .selectAll("line")
                  .data(d => [d, d])
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                node
                    .attr("transform", d => `translate(${d.x}, ${d.y})`);

                draw_dag_line(p_data);
            });
            
            function dragstarted(d) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
                hoverOn(d);
            }

            function dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            function dragended(d) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            trial.on("tick", p => {
                if (p_data.id == p.uid)
                    requestAnimationFrame(() => {
                        update_fissures();
                        draw_dag(p_data);
                        draw_dag_line(p_data);
                    });
            });
            function hoverOn(d) {
                let clear = d != p_data;
                if (p_data)
                    p_data.selected = false;
                
                d.selected = true;
                P = trial.peers[d.id];
                
                d3.selectAll("svg.network .nodes > g")
                    .classed("selected", d => d.selected);
                p_data = d;
                requestAnimationFrame(() => {
                    update_fissures();
                    draw_dag(d, clear);
                    draw_dag_line(d);
                });
            }
            
        }
        
        if (document.readyState === "complete" ||
            (document.readyState !== "loading" && !document.documentElement.doScroll)) {
            begin();
        } else {
            document.addEventListener("DOMContentLoaded", begin);
        }
        </script>
        <link rel="stylesheet" href="vis-sim.css">
    </head>
    <body>
        <svg class="network"></svg>
        <svg class="dag">
            <g class="fissures"></g>
            <g class="edges"></g>
            <g class="nodes"></g>
            <g class="arrows"></g>
        </svg>
        <div class="controls">
            <div>
                <label for="timing">Simulation Speed</label>
                <input type="range" min="0.5" max="3" value="1.5" step="0.01" id="timing">
            </div>
            <div>
                <label for="edit_prob">Edit rate</label>
                <input type="range" min="0" max="1" value="0.25" step="0.01" id="edit_prob">
            </div>
            <div>
                <label for="connect_prob">Disconnect and reconnect rate</label>
                <input type="range" min="0" max="1" value="0.1" step="0.01" id="connect_prob">
            </div>
        </div>
    </body>
</html>