<!DOCTYPE html>
<html>
    <head>
        <title>Peer-To-Peer Sync9</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <script src="https://dglittle.github.io/cdn/random001.js"></script>
        <script src="https://dglittle.github.io/cdn/utils004.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <script src="https://unpkg.com/d3-dag@0.2.6"></script>
        <script src="./sync9.js"></script>
        <script src="./sync9_peer.js"></script>
        <script src="./trial.js"></script>
        <script>
        var P = null;
        const N = 6;
        function begin() {
            var nodes = [];
            var links = [];
            var p_data = null;
            const elw = (document.documentElement.clientWidth > document.documentElement.clientHeight) ?
                document.documentElement.clientWidth/2 : document.documentElement.clientWidth;
            const elh = (document.documentElement.clientWidth > document.documentElement.clientHeight) ?
                document.documentElement.clientHeight - 70 : document.documentElement.clientHeight/2 - 35;

            document.getElementById('edit_prob').oninput = () => {
                const exp = -2 * Math.log(N)/Math.log(0.25);
                console.log(exp);
                EDIT_PROB = Math.pow(document.getElementById('edit_prob').value, exp);
                console.log(EDIT_PROB)
            };
            document.getElementById('edit_prob').oninput();

            document.getElementById('connect_prob').oninput = () => {
                CONNECT_PROB = document.getElementById('connect_prob').value;
            };
            document.getElementById('connect_prob').oninput();

            document.getElementById('timing').oninput = () => {
                TIMING = 1000*Math.pow(10, -document.getElementById('timing').value);
            };
            document.getElementById('timing').oninput();

            var trial = new Trial({
                peers: N});
            trial.on("topology", update_links);
            trial.on("edit", rec_edit);
            trial.begin();

            /* Recompute nodes and links when they get changed (ie, on the topology event) */
            function update_links(peers) {
                net_peers = peers;
                // Note the current number of links and nodes to see if they change.
                // The event should fire after a single change so we should never miss a change due to counting
                let nodes_old_len = nodes.length;
                let links_old_len = links.length;
                // Copy over the old nodes' locations so that we can update seamlessly
                let nodes_new = Object.keys(peers).map(uid => {
                    let node = {id: uid}
                    for (let peer of nodes) {
                        if (peer.id === uid) {
                            node.x = peer.x;
                            node.y = peer.y;
                            break;
                        }
                    }
                    if (!p_data) {
                        P = peers[uid];
                        node.selected = true;
                        p_data = node;
                    }
                    return node;
                })
                // Done computing nodes

                links = [];
                // Let's traverse the graph
                // Keep track of what we've seen
                let seen_peers = new Set();
                // Recursively explore the graph
                function add_links(peer) {
                    if (seen_peers.has(peer))
                        return;
                    seen_peers.add(peer);
                    for (let link of Object.keys(peers[peer].peers)) {
                        links.push({source: peer, target: link})
                        add_links(link)
                    }
                }
                // Pick the "first" peer and start traversing
                add_links(Object.keys(peers)[0]);
                // Done computing links

                // If the nodes or links changed, update them in the simulation
                // This might be unnecessary and it depends on the internals of the simulation
                if (nodes_new.length != nodes_old_len) {
                    nodes = nodes_new;
                    simulation.nodes(nodes);
                }
                if (links.length != links_old_len) {
                    simulation.force("link").links(links);
                }
                // Update graphics handles creating and deleting SVG elements
                if (nodes.length != nodes_old_len || links.length != links_old_len) {
                    update_graphics();
                    simulation.alpha(0.2).restart();
                }
            }
            /* When we get an edit, mark "edit time" on the peer that made it */
            function rec_edit(uid, edit) {
                let c = d3
                  .selectAll("svg.network .nodes > g")
                    .filter(d => d.id == uid)
                  .select("circle");
                if (c.classed("edit-blip-1")) {
                    c.classed("edit-blip-1", false);
                    c.classed("edit-blip-2", true);
                } else {
                    c.classed("edit-blip-2", false);
                    c.classed("edit-blip-1", true);
                }
            }
            /* Update the SVG elements with new or removed nodes and links */
            function update_graphics() {
                // Bind the nodes to the data
                node = node.data(nodes, d => d.id);
                // Remove deleted nodes
                node.exit().remove();
                // Add new nodes and draw circles on them
                let enter = node.enter()
                  .append("g")
                  .attr("data-pid", d => d.id);
                enter.append("circle")
                    .attr("r", 10)
                    .classed("node", true)
                enter.call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended))
                    .on('mouseover', hoverOn);
                node = node.merge(enter)
                    .classed("selected", d => d.selected);

                // Bind links, remove deleted, and add new.
                link = link.data(links, d => d.source.id + "-" + d.target.id);
                link.exit().remove();
                link = link.enter()
                            .append(() => {
                                   let group = document.createElementNS("http://www.w3.org/2000/svg","g");
                                   let back = document.createElementNS("http://www.w3.org/2000/svg","line");
                                   let front = document.createElementNS("http://www.w3.org/2000/svg","line");
                                   group.append(back, front);
                                   return group;
                               })
                                .merge(link);
            }
            /* Update fissure notifications for peers */
            var colors = {};
            function fis(f) {
                let m = f.a < f.b ? f.a : f.b,
                    p = f.a < f.b ? f.b : f.a;
                return {
                    min: m,
                    plus: p,
                    sign: f.a < f.b ? "+" : "-",
                    tag: `${m}:${p}`
                };
            };
            function update_fissures() {
                let fissures = new Set();
                for (let p of Object.values(trial.peers)) {
                    Object.values(p.fissures)
                        .forEach(f => fissures.add(fis(f).tag));
                }
                // Delete unused colors
                for (let f of Object.keys(colors)) {
                    if (!fissures.has(f))
                        delete colors[f];
                }
                for (let f of fissures) {
                    if (!colors[f]) {
                        // Let's find a new color
                        // What we want to do is find the color that is furthest away from every other color
                        let positions = Object.values(colors).map(c => c.angle).sort().concat([1]);
                        let best = 0,
                            biggest = positions[0];
                        for (let i = 0; i < positions.length - 1; i++) {
                            let smaller = positions[i];
                            let bigger = positions[i+1];
                            if (bigger - smaller > biggest) {
                                best = (bigger + smaller) / 2;
                                biggest = bigger - smaller;
                            }
                        }

                        colors[f] = {angle: best, color: d3.interpolateRainbow(best)};
                    }
                }
                
                let fdots = node
                  .selectAll("g.fissure")
                    .data(d => Object.values(trial.peers[d.id].fissures).map(fis),
                          f => f.tag+f.sign);
                
                fdots.exit().remove();

                let e = fdots
                  .enter()
                  .append("g")
                   .classed("fissure", true)
                
                e.append("circle")
                    .classed("fissure-circ", true)
                    .attr("r", 7)
                    .attr("fill", f => colors[f.tag].color);
                e.append('text')
                    .classed("fissure-sign", true)
                    .html(f => f.sign == "-" ? "&minus;" : "+")
                    .attr("y", 5);
                fdots = fdots.merge(e)
                    .attr("transform", (f, i) => `translate(${i * 18 + 20}, -10)`);
            }

            var s_fissure = null;
            var draw_n = 0;
            /* Draw the dag for a peer d */
            function draw_dag(d, clear) {
                // Get the timedag of the peer
                let pe = trial.peers[d.id];
                let timedag = Object.entries(pe.s9.T)
                    .map(([k, v]) => {
                        return {id: k, parentIds: Object.keys(v)};
                    });
                
                if (timedag.length > 500) {
                    d3.select("svg.dag").classed("disabled", true);
                    return false;
                }
                if (++draw_n * 50 < timedag.length) {
                    return false;
                }
                draw_n = 0;

                let x = pe.v_state();
                let z = pe.f_state();

                let dag = d3.dagStratify()(timedag);
                let layout = d3.sugiyama()
                    .size([elw, elh])
                    .layering(d3.layeringLongestPath())
                    .decross(d3.decrossTwoLayer())
                    .coord(d3.coordCenter());
                layout(dag);

                const dag_ho = Math.max(0, 375 - elh);
                const dag_wo = Math.max(0, 375 - elw);
                let svg = d3.select("svg.dag")
                    .classed("disabled", false)
                    .attr("width", elw)
                    .attr("height", elh)
                    .attr("viewBox", `-${dag_wo + 25} -${dag_ho + 25} ${elw+2*(25 + dag_wo)} ${elh+2*(25 + dag_ho)}`);
                if (clear)
                    svg.selectAll("g").selectAll("*").remove();
                
                // How to draw edges
                let line = d3.line()
                    //.curve(d3.curveCatmullRom)
                    .x(d => d.x)
                    .y(d => d.y);

                let fissures = Object.values(pe.fissures).map(fis);
                function color_nodes() {
                    svg
                      .selectAll('circle.dag-version')
                        .attr('stroke', ({id}) => z(id)[s_fissure] ? colors[s_fissure].color : "#4e6069");
                }
                
                // Plot edges
                let edges = svg.select("g.edges")
                  .selectAll('path')
                    .data(dag.links(), l => `${l.source.id}-${l.target.id}`);

                edges.enter()
                  .append('path')
                    .classed('dag-line', true)
                  .merge(edges)
                    .attr('d', ({ data }) => line(data.points));

                edges.exit().remove();
                
                let nodes = svg.select("g.nodes")
                  .selectAll('circle')
                    .data(dag.descendants(), n => n.id);
                
                nodes.enter()
                  .append('circle')
                    .classed('dag-version', true)
                    .attr('r', 10)
                    .attr('stroke', "#4e6069")
                    .attr("data-vid", ({id}) => id)
                  .merge(nodes)
                    .attr('cx', ({x, y}) => x)
                    .attr('cy', ({x, y}) => y)
                    .classed("frozen", ({id}) => x(id).frozen)
                    .classed("acked", ({id}) => x(id).acked)
                    .classed("fissured", ({id}) => Object.keys(z(id)).length);

                nodes.exit().remove();
                color_nodes();

                const arrowhead = d3.symbol().type(d3.symbolTriangle).size(60);
                let arrows = svg.select('g.arrows')
                  .selectAll('path')
                    .data(dag.links(), l => `${l.source.id}-${l.target.id}`);
                
                arrows.enter()
                  .append('path')
                    .classed('dag-arrow', true)
                    .attr('d', arrowhead)
                  .merge(arrows)
                    .attr('transform', ({data}) => {
                        // Last two points from the data
                        let [end, start] = data.points.reverse();
                        let dx = start.x - end.x;
                        let dy = start.y - end.y;
                        let scale = 12 / Math.sqrt(dx * dx + dy * dy);
                        // This is the angle of the last line segment
                        let angle = Math.atan2(-dy, -dx) * 180 / Math.PI + 90;
                        return `translate(${end.x + dx * scale}, ${end.y + dy * scale}) rotate(${angle})`;
                    });
                
                arrows.exit().remove();
                
                let fissure_bars = svg.select('g.fissures')
                  .selectAll('rect')
                    .data(fissures, f => f.tag);
                
                fissure_bars.enter()
                  .append('rect')
                    .classed('dag-select', true)
                    .attr('x', -(dag_wo + 50))
                    .attr('fill', f => colors[f.tag].color)
                    .on('mouseover', d => {
                        s_fissure = d.tag;
                        d3.select(d3.event.target)
                            .attr('width', 50);
                        setTimeout(() => color_nodes());
                    })
                    .on('mouseout', d => {
                        if (s_fissure === d.tag)
                            s_fissure = null;
                        d3.select(d3.event.target)
                            .attr('width', 30);
                        setTimeout(() => color_nodes());
                    })
                  .merge(fissure_bars)
                    .attr('width', d => s_fissure == d.tag ? 50 : 30)
                    .attr('height', elh/fissures.length)
                    .attr("y", (f, i) => elh/fissures.length * i);

                fissure_bars.exit().remove(); 
                    
            }

            const simulation = d3.forceSimulation()
                .force("link", d3.forceLink(links)
                                 .id(d => d.id)
                                 .distance(200))
                .force("repel", d3.forceManyBody()
                                   .strength(-1500)
                                   .distanceMax(400))
                .force("center", d3.forceCenter(elw/2, elh/2));
            
            // Somewhat boring d3 boilerplate
            const svg_ho = Math.max(0, 400 - elh);
            const svg_wo = Math.max(0, 400 - elw);
            const svg = d3.select("svg.network")
                          .attr("width", elw)
                          .attr("height", elh)
                          .attr("viewBox", `${-svg_wo} ${-svg_ho} ${elw+svg_wo*2} ${elh+svg_ho*2}`);
            
            var link = svg.append("g")
                          .classed("links", true)
                        .selectAll("line"),

                node = svg.append("g")
                          .classed("nodes", true)
                        .selectAll("g");

            update_links(trial.peers);

            simulation.on("tick", () => {
                // Move the nodes and lines
                nodes.forEach(d => {
                    d.x = Math.min(Math.max(10, d.x), elw-10);
                    d.y = Math.min(Math.max(10, d.y), elh-10);
                })
                link
                  .selectAll("line")
                  .data(d => [d, d])
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                node
                    .attr("transform", d => `translate(${d.x}, ${d.y})`);
            });
            
            function dragstarted(d) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
                hoverOn(d);
            }

            function dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            function dragended(d) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            trial.on("tick", p => {
                if (p_data.id == p.uid)
                    requestAnimationFrame(() => {update_fissures(); draw_dag(p_data)});
            });
            function hoverOn(d) {
                let clear = d != p_data;
                if (p_data)
                    p_data.selected = false;
                
                d.selected = true;
                P = trial.peers[d.id];
                
                d3.selectAll("svg.network .nodes > g")
                    .classed("selected", d => d.selected);
                p_data = d;
                requestAnimationFrame(() => {update_fissures(); draw_dag(d, clear)});
            }
            
        }
        
        if (document.readyState === "complete" ||
            (document.readyState !== "loading" && !document.documentElement.doScroll)) {
            begin();
        } else {
            document.addEventListener("DOMContentLoaded", begin);
        }
        </script>
        <style>
            :root {
                --off-white: #ddd;
                --off-black: #222;
                --n-controls: 3;
            }
            body {
                padding: 0;
                margin: 0;
                padding-bottom: calc(var(--n-controls) * 22px);
                position: absolute;
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                background: var(--off-black);
            }
            .controls {
                position: absolute;
                bottom: 10px;
                right: 10px;
                z-index: 10;
                height: calc(var(--n-controls) * 22px);
            }
            .controls div {
                display: flex;
                justify-content: space-between;
                opacity: 0.5;
                transition: 0.15s opacity ease;
                height: calc(100% / var(--n-controls));
            }
            .controls div:hover {
                opacity: 1;
            }
            .controls label {
                color: var(--off-white);
                font-family: Roboto, sans-serif;
                margin-right: 1ch;
            }
            .controls input {
                cursor: pointer;
            }

            /* Network SVG Styling*/
            /* Network line shadows */
            svg.network .links > g > line:first-child {
                stroke: rgba(30, 30, 30, 0.5);
                stroke-width: 6;
            }
            svg.network .links > g > line:last-child {
                stroke: var(--off-white);
                stroke-width: 4;
            }
            svg.network .nodes > g > circle {
                stroke-width: 3;
                fill: #c8dcf0;
                stroke: #786e60;
                cursor: pointer;

                animation-timing-function: cubic-bezier(.22,.61,.36,1);
                animation-duration: 2s;
            }
            svg.network .nodes g.selected > circle {
                stroke: #b525c2;
            }
            .edit-blip-1 {animation-name: edit-blip-1;}
            .edit-blip-2 {animation-name: edit-blip-2;}
            @keyframes edit-blip-1 {
                from {fill: rgb(20, 100, 200);}
                to {fill: #c8dcf0;}
            }
            @keyframes edit-blip-2 {
                from {fill: rgb(20, 100, 200);}
                to {fill: #c8dcf0;}
            }
            svg.network .fissure,
            svg.network .fissure * {
                cursor: default;
            }
            svg.network .fissure text.fissure-sign {
                font-weight: bold;
                font-family: sans-serif;
                text-anchor: middle;
                fill: white;
                font-size: 14px;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            /* TimeDAG styling */
            svg.dag.disabled {
                filter: blur(2px) grayscale(85%) brightness(0.7);
                pointer-events: none;
            }
            svg.dag .dag-line {
                fill: none;
                stroke-width: 3;
                stroke: var(--off-white);
            }
            svg.dag .dag-arrow {
                fill: var(--off-white);
            }
            svg.dag .dag-version {
                fill: #dadae0;
                stroke-width: 3;
            }
            svg.dag .dag-version.acked {
                fill: #42c260;
            }
            svg.dag .dag-version.acked.frozen {
                fill: #f7e136;
            }
            svg.dag .fissure-line {
                stroke-width: 2;
                stroke-opacity: 0.7;
                fill: none;
            }
            svg.dag .fissure-fill {
                fill-opacity: 0.3;
            }
            
            @media screen and (max-aspect-ratio: 1/1) {
                body {
                    padding-bottom: 0;
                }
                body {
                    flex-direction: column;
                }
                .controls {
                    position: initial;
                    width: 100%;
                }
                .controls div {
                    padding-left: 5px;
                    padding-right: 5px;
                }
            }
            @media screen and (max-width: 400px) {
                .controls label {
                    font-size: 13px;
                }
            }
        </style>
    </head>
    <body>
        <svg class="dag">
            <g class="edges"></g>
            <g class="nodes"></g>
            <g class="arrows"></g>
            <g class="fissures"></g>
        </svg>
        <svg class="network"></svg>
        <div class="controls">
            <div>
                <label for="timing">Simulation Speed</label>
                <input type="range" min="0" max="3" value="1" step="0.01" id="timing">
            </div>
            <div>
                <label for="edit_prob">Edit rate</label>
                <input type="range" min="0" max="1" value="0.25" step="0.01" id="edit_prob">
            </div>
            <div>
                <label for="connect_prob">Disconnect and reconnect rate</label>
                <input type="range" min="0" max="1" value="0.1" step="0.01" id="connect_prob">
            </div>
        </div>
    </body>
</html>