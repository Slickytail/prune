<!DOCTYPE html>
<html>
    <head>
        <title>Peer-To-Peer Sync9</title>
        <meta charset="utf-8">
        <script src="https://dglittle.github.io/cdn/random001.js"></script>
        <script src="https://dglittle.github.io/cdn/utils004.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <script src="./sync9.js"></script>
        <script src="./sync9_peer.js"></script>
        <script src="./trial.js"></script>
        <script>
        function begin() {
            var nodes = [];
            var links = [];
            const timing = 50;
            var trial = new Trial({
                timing: timing,
                peers: 6});
            trial.on("topology", update_links);
            trial.on("edit", rec_edit);
            trial.begin();

            /* Recompute nodes and links when they get changed (ie, on the topology event) */
            function update_links(peers) {
                // Note the current number of links and nodes to see if they change.
                // The event should fire after a single change so we should never miss a change due to counting
                let nodes_old_len = nodes.length;
                let links_old_len = links.length;
                // Copy over the old nodes' locations so that we can update seamlessly
                let nodes_new = Object.keys(peers).map(vid => {
                    let node = {id: vid}
                    for (let peer of nodes) {
                        if (peer.id === vid) {
                            node.x = peer.x;
                            node.y = peer.y;
                            break;
                        }
                    }
                    return node;
                })
                // Done computing nodes

                links = [];
                // Let's traverse the graph
                // Keep track of what we've seen
                let seen_peers = new Set();
                // Recursively explore the graph
                function add_links(peer) {
                    if (seen_peers.has(peer))
                        return;
                    seen_peers.add(peer);
                    for (let link of Object.keys(peers[peer].peers)) {
                        links.push({source: peer, target: link})
                        add_links(link)
                    }
                }
                // Pick the "first" peer and start traversing
                add_links(Object.keys(peers)[0]);
                // Done computing links

                // If the nodes or links changed, update them in the simulation
                // This might be unnecessary and it depends on the internals of the simulation
                if (nodes_new.length != nodes_old_len) {
                    nodes = nodes_new;
                    simulation.nodes(nodes);
                }
                if (links.length != links_old_len) {
                    simulation.force("link").links(links);
                }
                // Update graphics handles creating and deleting SVG elements
                if (nodes.length != nodes_old_len || links.length != links_old_len) {
                    update_graphics();
                    simulation.alpha(0.2).restart();
                }
            }
            /* When we get an edit, mark "edit time" on the peer that made it */
            function rec_edit(uid, edit) {
                for (var node of nodes) {
                    if (node.id === uid) {
                        node.et = 0;
                    }
                }
            }
            /* Update the SVG elements with new or removed nodes and links */
            function update_graphics() {
                // Bind the nodes to the data
                node = node.data(nodes, d => d.id);
                // Remove deleted nodes
                node.exit().remove();
                // Add new nodes and draw circles on them
                node = node.enter()
                               .append("circle")
                                   .attr("r", 7)
                                   .call(d3.drag()
                                       .on("start", dragstarted)
                                       .on("drag", dragged)
                                       .on("end", dragended))
                               .merge(node);

                // Bind links, remove deleted, and add new.
                link = link.data(links, d => d.source.id + "-" + d.target.id);
                link.exit().remove();
                link = link.enter()
                               .append(() => {
                                   let group = document.createElementNS("http://www.w3.org/2000/svg","g");
                                   let back = document.createElementNS("http://www.w3.org/2000/svg","line");
                                   let front = document.createElementNS("http://www.w3.org/2000/svg","line");
                                   group.append(back, front);
                                   return group;
                               })
                            .merge(link);
            }

            function tick() {
                // Draw edit blips
                for (let n of nodes) {
                    n.et = (n.et || 0) + 1
                }
                let col = function (et) {
                    let r = 200 * (1 - Math.exp(-0.05*et));
                    let g = 120 * (1 - Math.exp(-0.1*et)) + 100;
                    let b = 240;
                    return {r: r, g: g, b: b}
                }
                let f = function (et) {
                    let c = col(et);
                    return `rgb(${c.r},${c.g},${c.b})`
                }
                let s = function(et) {
                    let c = col(et);
                    return `rgb(${c.r * 0.6},${c.g * 0.5},${c.b * 0.4})`
                }
                node.attr("fill", d => f(d.et))
                    .attr("stroke", d => s(d.et));
                setTimeout(tick, 20);
            }
            setTimeout(tick);

            // Somewhat boring d3 boilerplate
            var size = Math.min(document.documentElement.clientWidth, document.documentElement.clientHeight);
            const svg = d3.select("svg")
                          .attr("width", size)
                          .attr("height", size);
            
            var link = svg.append("g")
                          .classed("links", true)
                        .selectAll("line"),

                node = svg.append("g")
                          .attr("stroke-width", 2)
                        .selectAll("circle");

            const simulation = d3.forceSimulation()
                .force("link", d3.forceLink(links)
                                 .id(d => d.id)
                                 .distance(200))
                .force("repel", d3.forceManyBody()
                                   .strength(-1500)
                                   .distanceMax(400))
                .force("center", d3.forceCenter(size/2, size/2));

            update_links(trial.peers);

            simulation.on("tick", () => {
                // Move the nodes and lines
                link
                  .selectAll("line")
                  .data(d => [d, d])
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
            });
            
            function dragstarted(d) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            function dragended(d) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }
        
        if (document.readyState === "complete" ||
            (document.readyState !== "loading" && !document.documentElement.doScroll)) {
            begin();
        } else {
            document.addEventListener("DOMContentLoaded", begin);
        }
        </script>
        <style>
            body {
                padding: 0;
                margin: 0;
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                background: #222;
            }
            .links > g > line:first-child {
                stroke: rgba(30, 30, 30, 0.5);
                stroke-width: 5;
            }
            .links > g > line:last-child {
                stroke: #ccc;
                stroke-width: 2.5;
            }
        </style>
    </head>
    <body>
        <svg>
        </svg>
    </body>
</html>