<!DOCTYPE html>
<html>
    <head>
        <title>Peer-To-Peer Sync9</title>
        <meta charset="utf-8">
        <script src="https://dglittle.github.io/cdn/random001.js"></script>
        <script src="https://dglittle.github.io/cdn/utils004.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <script src="https://unpkg.com/d3-dag@0.2.6"></script>
        <script src="./sync9.js"></script>
        <script src="./sync9_peer.js"></script>
        <script src="./trial.js"></script>
        <script>
        function begin() {
            var nodes = [];
            var links = [];
            const size = (document.documentElement.clientWidth > document.documentElement.clientHeight) ?
                Math.min(document.documentElement.clientWidth/2, document.documentElement.clientHeight) :
                Math.min(document.documentElement.clientWidth, document.documentElement.clientHeight/2);
            EDIT_PROB = document.getElementById('edit_prob').value;
            CONNECT_PROB = document.getElementById('connect_prob').value;
            var trial = new Trial({
                timing: 50,
                peers: 5});
            trial.on("topology", update_links);
            trial.on("edit", rec_edit);
            trial.begin();

            /* Recompute nodes and links when they get changed (ie, on the topology event) */
            function update_links(peers) {
                net_peers = peers;
                // Note the current number of links and nodes to see if they change.
                // The event should fire after a single change so we should never miss a change due to counting
                let nodes_old_len = nodes.length;
                let links_old_len = links.length;
                // Copy over the old nodes' locations so that we can update seamlessly
                let nodes_new = Object.keys(peers).map(uid => {
                    let node = {id: uid}
                    for (let peer of nodes) {
                        if (peer.id === uid) {
                            node.x = peer.x;
                            node.y = peer.y;
                            break;
                        }
                    }
                    return node;
                })
                // Done computing nodes

                links = [];
                // Let's traverse the graph
                // Keep track of what we've seen
                let seen_peers = new Set();
                // Recursively explore the graph
                function add_links(peer) {
                    if (seen_peers.has(peer))
                        return;
                    seen_peers.add(peer);
                    for (let link of Object.keys(peers[peer].peers)) {
                        links.push({source: peer, target: link})
                        add_links(link)
                    }
                }
                // Pick the "first" peer and start traversing
                add_links(Object.keys(peers)[0]);
                // Done computing links

                // If the nodes or links changed, update them in the simulation
                // This might be unnecessary and it depends on the internals of the simulation
                if (nodes_new.length != nodes_old_len) {
                    nodes = nodes_new;
                    simulation.nodes(nodes);
                }
                if (links.length != links_old_len) {
                    simulation.force("link").links(links);
                }
                // Update graphics handles creating and deleting SVG elements
                if (nodes.length != nodes_old_len || links.length != links_old_len) {
                    update_graphics();
                    simulation.alpha(0.2).restart();
                }
            }
            /* When we get an edit, mark "edit time" on the peer that made it */
            function rec_edit(uid, edit) {
                for (var node of nodes) {
                    if (node.id === uid) {
                        node.et = 0;
                    }
                }
            }
            /* Update the SVG elements with new or removed nodes and links */
            function update_graphics() {
                // Bind the nodes to the data
                node = node.data(nodes, d => d.id);
                // Remove deleted nodes
                node.exit().remove();
                // Add new nodes and draw circles on them
                node = node.enter()
                               .append("circle")
                                   .attr("r", 10)
                                   .call(d3.drag()
                                       .on("start", dragstarted)
                                       .on("drag", dragged)
                                       .on("end", dragended))
                                    .on('mouseover', hoverOn)
                               .merge(node);

                // Bind links, remove deleted, and add new.
                link = link.data(links, d => d.source.id + "-" + d.target.id);
                link.exit().remove();
                link = link.enter()
                            .append(() => {
                                   let group = document.createElementNS("http://www.w3.org/2000/svg","g");
                                   let back = document.createElementNS("http://www.w3.org/2000/svg","line");
                                   let front = document.createElementNS("http://www.w3.org/2000/svg","line");
                                   group.append(back, front);
                                   return group;
                               })
                                .merge(link);
            }

            function draw_dag(d) {
                // Get the timedag of the peer
                let pe = trial.peers[d.id];
                let x = pe.v_state();
                let timedag_data = pe.s9.T;
                let timedag = Object.entries(timedag_data)
                    .map(([k, v]) => {
                        return {id: k, parentIds: Object.keys(v)};
                    });
                let dag = d3.dagStratify()(timedag);
                let layout = d3.sugiyama()
                    .size([size-50, size-50])
                    .layering(d3.layeringLongestPath())
                    .decross(d3.decrossTwoLayer())
                    .coord(d3.coordCenter());
                layout(dag);
                let svg = d3.select("svg.dag")
                    .attr("width", size)
                    .attr("height", size)
                    .attr("viewBox", `-25 -25 ${size} ${size}`);
                svg.selectAll("g").remove();
                
                // How to draw edges
                let line = d3.line()
                    //.curve(d3.curveCatmullRom)
                    .x(d => d.x)
                    .y(d => d.y);
                
                // Plot edges
                svg.append('g')
                  .selectAll('path')
                    .data(dag.links())
                    .enter()
                  .append('path')
                    .classed('dag-line', true)
                    .attr('d', ({ data }) => line(data.points));
                
                svg.append('g')
                  .selectAll('g')
                    .data(dag.descendants())
                    .enter()
                  .append('circle')
                    .classed('dag-version', true)
                    .attr('r', 10)
                    .attr('cx', ({x, y}) => x)
                    .attr('cy', ({x, y}) => y)
                    .classed("frozen", ({id}) => x(id).frozen)
                    .classed("acked", ({id}) => x(id).acked)
                    .classed("fissured", ({id}) => x(id).fissures.length > 0);

                    const arrow = d3.symbol().type(d3.symbolTriangle).size(60);
                    svg.append('g')
                      .selectAll('path')
                        .data(dag.links())
                        .enter()
                      .append('path')
                        .classed('dag-arrow', true)
                        .attr('d', arrow)
                        .attr('transform', ({data}) => {
                            // Last two points from the data
                            let [end, start] = data.points.reverse();
                            let dx = start.x - end.x;
                            let dy = start.y - end.y;
                            let scale = 12 / Math.sqrt(dx * dx + dy * dy);
                            // This is the angle of the last line segment
                            let angle = Math.atan2(-dy, -dx) * 180 / Math.PI + 90;
                            return `translate(${end.x + dx * scale}, ${end.y + dy * scale}) rotate(${angle})`;
                        });

            }

            var t_old = performance.now();
            function tick(time) {
                var elapsed = (time - t_old);
                t_old = time;

                // Draw edit blips
                for (let n of nodes) {
                    if (n.et == null)
                        n.et = Infinity;
                    else
                        n.et += elapsed;
                }
                let col = function (et) {
                    let r = 200 * (1 - Math.exp(et/-1000));
                    let g = 120 * (1 - Math.exp(et/-500)) + 100;
                    let b = 240;
                    return {r: r, g: g, b: b}
                }
                let f = function (et) {
                    let c = col(et);
                    return `rgb(${c.r},${c.g},${c.b})`
                }
                let s = function(d) {
                    let c = col(d.et);
                    return d.selected ? 
                        `rgb(181, 37, 194)` :
                        `rgb(${c.r * 0.6},${c.g * 0.5},${c.b * 0.4})`;

                }
                node.attr("fill", d => f(d.et))
                    .attr("stroke", d => s(d));
                
                requestAnimationFrame(tick)
            }
            requestAnimationFrame(tick);

            const simulation = d3.forceSimulation()
                .force("link", d3.forceLink(links)
                                 .id(d => d.id)
                                 .distance(200))
                .force("repel", d3.forceManyBody()
                                   .strength(-1500)
                                   .distanceMax(400))
                .force("center", d3.forceCenter(size/2, size/2));
            
            // Somewhat boring d3 boilerplate
            const svg = d3.select("svg.network")
                          .attr("width", size)
                          .attr("height", size)
                          .attr("viewBox", `0 0 ${size} ${size}`);
            
            var link = svg.append("g")
                          .classed("links", true)
                        .selectAll("line"),

                node = svg.append("g")
                          .classed("nodes", true)
                        .selectAll("circle");

            update_links(trial.peers);

            simulation.on("tick", () => {
                // Move the nodes and lines
                link
                  .selectAll("line")
                  .data(d => [d, d])
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
            });
             
            function dragstarted(d) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            function dragended(d) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            var dag = null;
            trial.on("tick", (p) => {
                if (!dag)
                    dag = {id: p.uid}
                if (dag.id == p.uid)
                    requestAnimationFrame(() => draw_dag(dag));
            });
            function hoverOn(d) {
                if (dag)
                    dag.selected = false;
                d.selected = true;
                dag = d;
                requestAnimationFrame(() => draw_dag(dag));
            }
            
        }
        
        if (document.readyState === "complete" ||
            (document.readyState !== "loading" && !document.documentElement.doScroll)) {
            begin();
        } else {
            document.addEventListener("DOMContentLoaded", begin);
        }
        </script>
        <style>
            :root {
                --off-white: #ddd;
                --off-black: #222;
            }
            body {
                padding: 0;
                margin: 0;
                position: absolute;
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                background: var(--off-black);
            }
            svg.network circle {
                cursor: pointer;
            }
            .controls {
                position: absolute;
                bottom: 10px;
                right: 10px;
            }
            .controls div {
                display: flex;
                justify-content: space-between;
                opacity: 0.5;
                transition: 0.15s opacity ease;
            }
            .controls div:hover {
                opacity: 1;
            }
            .controls label {
                color: var(--off-white);
                font-family: Roboto, sans-serif;
                margin-right: 1ch;
            }
            .controls input {
                cursor: pointer;
            }

            /* Network SVG Styling*/
            /* Network line shadows */
            svg.network .links > g > line:first-child {
                stroke: rgba(30, 30, 30, 0.5);
                stroke-width: 6;
            }
            svg.network .links > g > line:last-child {
                stroke: var(--off-white);
                stroke-width: 4;
            }
            svg.network .nodes circle {
                stroke-width: 3;
            }

            /* TimeDAG styling */
            svg.dag .dag-line {
                fill: none;
                stroke-width: 3;
                stroke: var(--off-white)
            }
            svg.dag .dag-arrow {
                fill: var(--off-white)
            }
            svg.dag .dag-version {
                stroke-width: 3;
                stroke: #4e6069;
                fill: #dadae0;
            }
            svg.dag .dag-version.frozen {
                fill: #8de4f7;
            }
            svg.dag .dag-version.acked {
                fill: #42c260;
            }
            svg.dag .dag-version.acked.frozen {
                fill: #f7e136;
            }
            svg.dag .dag-version.fissured {
                stroke: #942c2c;
            }
        </style>
    </head>
    <body>
        <svg class="dag"></svg>
        <svg class="network"></svg>
        <div class="controls">
            <div>
                <label for="edit_prob">Edit rate</label>
                <input type="range" min="0" max="1" value="0.1" step="0.01" id="edit_prob" oninput="EDIT_PROB = this.value;">
            </div>
            <div>
                <label for="connect_prob">Disconnect and reconnect rate</label>
                <input type="range" min="0" max="1" value="0.1" step="0.01" id="connect_prob" oninput="CONNECT_PROB = this.value;">
            </div>
        </div>
    </body>
</html>